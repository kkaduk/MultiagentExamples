This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: coordinator-agent/src
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
coordinator-agent/
  src/
    main/
      java/
        com/
          example/
            coordinator/
              conversation/
                advisor/
                  CoordynatorAgentAdvisor.java
                  QuestionRewriteAdvisor.java
                  WorkerAgentAdvisor.java
                ConversationMemoryChatMemory.java
              customizer/
                CustomMcpSyncClientCustomizer.java
              model/
                AggregatedResult.java
                TaskAssignmentDTO.java
                WorkerSkilsDTO.java
                WorkerTask.java
              service/
                WorkerAgentService.java
              tools/
                PromptTemplateTools.java
                TaskPromptGenerator.java
              workflow/
                WorkflowController.java
                WorkflowOrchestrator.java
                WorkflowParser.java
                WorkflowTask.java
              CoordinatorAgent.java
              CoordinatorApplication.java
              TaskDispatcher.java
      resources/
        application.yml

================================================================
Files
================================================================

================
File: coordinator-agent/src/main/java/com/example/coordinator/conversation/advisor/CoordynatorAgentAdvisor.java
================
package com.example.coordinator.conversation.advisor;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.ai.chat.client.advisor.api.AdvisedRequest;
import org.springframework.ai.chat.client.advisor.api.AdvisedResponse;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisor;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisorChain;
import org.springframework.ai.chat.client.advisor.api.StreamAroundAdvisor;
import org.springframework.ai.chat.client.advisor.api.StreamAroundAdvisorChain;

import com.example.coordinator.model.WorkerSkilsDTO;
import static com.example.coordinator.tools.TaskPromptGenerator.generatePrompt;

import lombok.NonNull;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

public class CoordynatorAgentAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {

    public static final String ORIGINAL_QUERY = "original_query";
    public static final String REWRITTEN_QUERY = "rewritten_query";

    private final boolean protectFromBlocking;
    private final int order;

    public CoordynatorAgentAdvisor(boolean protectFromBlocking, int order) {
        this.protectFromBlocking = protectFromBlocking;
        this.order = order;
    }

    public CoordynatorAgentAdvisor() {
        this(true, 0);
    }
    public static Builder builder() {
        return new Builder();
    }

    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    @Override
    public int getOrder() {
        return this.order;
    }

    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        AdvisedRequest advisedRequestModified = before(advisedRequest);
        AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequestModified);
        return after(advisedResponse);
    }

    @Override
    public Flux<AdvisedResponse> aroundStream(@NonNull AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        Flux<AdvisedResponse> advisedResponses = (this.protectFromBlocking)
                ? Mono.just(advisedRequest)
                        .publishOn(Schedulers.boundedElastic())
                        .map(this::before)
                        .flatMapMany(chain::nextAroundStream)
                : chain.nextAroundStream(before(advisedRequest));

        return advisedResponses.map(this::after);
    }

    private AdvisedRequest before(AdvisedRequest request) {
        Map<String, Object> context = new HashMap<>(request.adviseContext());

        // Capture the original query.
        String originalQuery = request.userText();
        context.put(ORIGINAL_QUERY, originalQuery);
        List<WorkerSkilsDTO> workers = Receptionist.getRegisteredWorkerSkils();

        String taskDistributionPrompt = generatePrompt(originalQuery, workers);
        context.put(REWRITTEN_QUERY, taskDistributionPrompt);
        return AdvisedRequest.from(request)
                .userText(taskDistributionPrompt)
                .adviseContext(context)
                .build();
    }

    private AdvisedResponse after(AdvisedResponse advisedResponse) {
        // Optionally, you can add rewriting metadata to the response.
        return advisedResponse;
    }

    /**
     * Builder for CoordynatorAgentAdvisor.
     */
    public static final class Builder {
        private boolean protectFromBlocking = true;
        private int order = 0;

        private Builder() {
        }

        /**
         * Sets whether to protect from blocking threads.
         *
         * @param protectFromBlocking true if protection is desired, false otherwise
         * @return this builder instance
         */
        public Builder protectFromBlocking(boolean protectFromBlocking) {
            this.protectFromBlocking = protectFromBlocking;
            return this;
        }

        /**
         * Sets the order of this advisor.
         *
         * @param order the advisor order
         * @return this builder instance
         */
        public Builder order(int order) {
            this.order = order;
            return this;
        }

        /**
         * Builds a CoordynatorAgentAdvisor instance.
         *
         * @return a new CoordynatorAgentAdvisor
         */
        public CoordynatorAgentAdvisor build() {
            return new CoordynatorAgentAdvisor(protectFromBlocking, order);
        }
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/conversation/advisor/QuestionRewriteAdvisor.java
================
package com.example.coordinator.conversation.advisor;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.ai.anthropic.AnthropicChatModel;
import org.springframework.ai.anthropic.AnthropicChatOptions;
import org.springframework.ai.anthropic.api.AnthropicApi;
import org.springframework.ai.chat.client.advisor.api.AdvisedRequest;
import org.springframework.ai.chat.client.advisor.api.AdvisedResponse;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisor;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisorChain;
import org.springframework.ai.chat.client.advisor.api.StreamAroundAdvisor;
import org.springframework.ai.chat.client.advisor.api.StreamAroundAdvisorChain;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.ai.ollama.OllamaChatModel;
import org.springframework.ai.ollama.api.OllamaApi;
import org.springframework.ai.ollama.api.OllamaOptions;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.Assert;

import lombok.NonNull;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

/**
 * Advisor that rewrites the user query to be more concise and easier to
 * understand.
 *
 * <p>
 * This advisor intercepts the user query, applies a rewriting template, and
 * replaces the original query with the rewritten version. The original and
 * rewritten queries are stored in the advice context.
 * </p>
 *
 * @author
 * @since 1.0.0
 */

public class QuestionRewriteAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {

    public static final String ORIGINAL_QUERY = "original_query";
    public static final String REWRITTEN_QUERY = "rewritten_query";

    //FIXME: The agents are hardcoded in the template. This should be dynamic.
    //It will be better to use the agent card to get the skills and agents.
    private static final String DEFAULT_QUERY_REWRITE_TEMPLATE = """
           Rewrite the following prompt to make it more [simple | formal | technical | optimized for ChatGPT | clear | specific]:
            {user_query}
            """;

    private final String queryRewriteTemplate;
    private final boolean protectFromBlocking;
    private final int order;

    @Value("${spring.ai.anthropic.api-key}")
    private String athKey;
    // private static ChatClient chatClient;

    /**
     * Creates a QueryRewriteAdvisor with the default rewriting template.
     */
    public QuestionRewriteAdvisor() {
        this(DEFAULT_QUERY_REWRITE_TEMPLATE, true, 0);
    }

    /**
     * Creates a QueryRewriteAdvisor with the specified rewriting template.
     *
     * @param queryRewriteTemplate the template used to rewrite the query
     * @param protectFromBlocking  if true the advisor will protect execution from
     *                             blocking threads
     * @param order                the order of the advisor
     */
    public QuestionRewriteAdvisor(String queryRewriteTemplate, boolean protectFromBlocking,
            int order) {
        Assert.hasText(queryRewriteTemplate, "The queryRewriteTemplate must not be empty!");
        this.queryRewriteTemplate = queryRewriteTemplate;
        this.protectFromBlocking = protectFromBlocking;
        this.order = order;
    }

    /**
     * Creates a builder for a QueryRewriteAdvisor.
     *
     * @return the builder instance
     */
    public static Builder builder() {
        return new Builder();
    }

    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    @Override
    public int getOrder() {
        return this.order;
    }

    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        AdvisedRequest advisedRequestModified = before(advisedRequest);
        AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequestModified);
        return after(advisedResponse);
    }

    @Override
    public Flux<AdvisedResponse> aroundStream(@NonNull AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        Flux<AdvisedResponse> advisedResponses = (this.protectFromBlocking)
                ? Mono.just(advisedRequest)
                        .publishOn(Schedulers.boundedElastic())
                        .map(this::before)
                        .flatMapMany(chain::nextAroundStream)
                : chain.nextAroundStream(before(advisedRequest));

        return advisedResponses.map(this::after);
    }

    private AdvisedRequest before(AdvisedRequest request) {
        Map<String, Object> context = new HashMap<>(request.adviseContext());

        // Capture the original query.
        String originalQuery = request.userText();
        context.put(ORIGINAL_QUERY, originalQuery);

        // Rewrite the query using the rewriting template.
        // This uses a PromptTemplate that replaces the {user_query} placeholder.
        String templetedQuery = new PromptTemplate(this.queryRewriteTemplate, Map.of("user_query", originalQuery))
                .render();
        context.put(REWRITTEN_QUERY, templetedQuery);

        var claudeRewrite = chatClaude(templetedQuery);

        // Replace the original user text with the message to worker.
        return AdvisedRequest.from(request)
                .userText(claudeRewrite)
                .adviseContext(context)
                .build();
    }

    private AdvisedResponse after(AdvisedResponse advisedResponse) {
        // Optionally, you can add rewriting metadata to the response.
        return advisedResponse;
    }

    /**
     * Builder for QueryRewriteAdvisor.
     */
    public static final class Builder {
        private String queryRewriteTemplate = DEFAULT_QUERY_REWRITE_TEMPLATE;
        private boolean protectFromBlocking = true;
        private int order = 0;

        private Builder() {
        }

        /**
         * Sets a custom rewriting template.
         *
         * @param queryRewriteTemplate the template to use for rewriting
         * @return this builder instance
         */
        public Builder queryRewriteTemplate(String queryRewriteTemplate) {
            Assert.hasText(queryRewriteTemplate, "The queryRewriteTemplate must not be empty!");
            this.queryRewriteTemplate = queryRewriteTemplate;
            return this;
        }

        /**
         * Sets whether to protect from blocking threads.
         *
         * @param protectFromBlocking true if protection is desired, false otherwise
         * @return this builder instance
         */
        public Builder protectFromBlocking(boolean protectFromBlocking) {
            this.protectFromBlocking = protectFromBlocking;
            return this;
        }

        /**
         * Sets the order of this advisor.
         *
         * @param order the advisor order
         * @return this builder instance
         */
        public Builder order(int order) {
            this.order = order;
            return this;
        }

        /**
         * Builds a QueryRewriteAdvisor instance.
         *
         * @return a new QueryRewriteAdvisor
         */
        public QuestionRewriteAdvisor build() {
            return new QuestionRewriteAdvisor(queryRewriteTemplate, protectFromBlocking, order);
        }
    }

    private String chatLlama(String prompt) {

        OllamaApi ollamaApi = new OllamaApi("http://homemainstation:11434");

        OllamaChatModel chatModel = OllamaChatModel.builder()
                // .ollamaApi(new OllamaApi())
                .ollamaApi(ollamaApi)
                .defaultOptions(
                        OllamaOptions.builder()
                                .internalToolExecutionEnabled(true)
                                .model("qwq:latest")
                                .topK(99)
                                .temperature(66.6)
                                .numGPU(0)
                                .build())
                .build();

        // Message message = MessageBuilder.createMessage(payload, messageHeaders);
        var resp = chatModel.call(prompt);
        return resp;

    }

    private String chatClaude(String prompt) {

        AnthropicApi api = new AnthropicApi(athKey);
        var options = AnthropicChatOptions.builder()
                .model(AnthropicApi.ChatModel.CLAUDE_3_HAIKU.getValue())
                .maxTokens(2048)
                .stopSequences(List.of("this-is-the-end"))
                .temperature(0.7)
                .topK(1)
                .topP(1.0)
                .httpHeaders(Map.of("x-api-key", System.getenv("ANTHROPIC_API_KEY")))
                // .model("claude-3-5-sonnet-20240620")
                .build();
        AnthropicChatModel chatModel = AnthropicChatModel.builder()
                .anthropicApi(api)
                .defaultOptions(options)
                .build();

        Prompt prm = new Prompt(prompt, options);

        // List<String> collection = ChatClient.create(chatModel).prompt()
        // .user(u -> u.text("List five {subject}")
        // .param("subject", "ice cream flavors"))
        // .call()
        // .entity(new ParameterizedTypeReference<>() {
        // });

        var resp = chatModel.call(prm);

        return resp.getResult().getOutput().getText();

    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/conversation/advisor/WorkerAgentAdvisor.java
================
package com.oracle.mcp.client.kb.chat.conversation.advisor;

public class WorkerAgentAdvisor {

}

================
File: coordinator-agent/src/main/java/com/example/coordinator/conversation/ConversationMemoryChatMemory.java
================
package com.example.coordinator.conversation;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.MessageType;


public class ConversationMemoryChatMemory implements ChatMemory {

    Map<String, List<Message>> conversationHistory = new ConcurrentHashMap<>();

    @Override
    public void add(String conversationId, List<Message> messages) {

        List<Message> userMessages = conversationHistory.getOrDefault(conversationId, new ArrayList<>());

        for (Message message : messages) {
            if (message.getMessageType() == MessageType.USER) {
                userMessages.add(message);
                conversationHistory.put(conversationId, userMessages);
            }
        }

       
    }

    @Override
    public List<Message> get(String conversationId, int lastN) {
        List<Message> all = this.conversationHistory.get(conversationId);
        return all != null ? all.stream().skip(Math.max(0, all.size() - lastN)).toList() : List.of();
    }

    @Override
    public void clear(String conversationId) {
        this.conversationHistory.remove(conversationId);
    }

}

================
File: coordinator-agent/src/main/java/com/example/coordinator/customizer/CustomMcpSyncClientCustomizer.java
================
package com.example.coordinator.customizer;

import java.time.Duration;
import java.util.List;

import org.springframework.ai.mcp.customizer.McpSyncClientCustomizer;
import org.springframework.stereotype.Component;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.spec.McpSchema;
import io.modelcontextprotocol.spec.McpSchema.CreateMessageResult;
import io.modelcontextprotocol.spec.McpSchema.CreateMessageResult.StopReason;
import io.modelcontextprotocol.spec.McpSchema.Root;

@Component
public class CustomMcpSyncClientCustomizer implements McpSyncClientCustomizer {
    @Override
    public void customize(String serverConfigurationName, McpClient.SyncSpec spec) {

        // Customize the request configuration
        spec.requestTimeout(Duration.ofSeconds(60));

        // Instantiate using the record’s generated constructor
        Root rootInstance = new Root("file:///Users/KKADUK/Project/Ontology/mcpclient", "My File Resource");

        // Sets the root URIs that the server connecto this client can access.
        spec.roots(rootInstance); // Could be LIS as well

        // Sets a custom sampling handler for processing message creation requests.
        spec.sampling(request -> {

            var meta = request.messages();

            
            // Construct the result (not a Mono)
            CreateMessageResult result = CreateMessageResult.builder()
                    .message("serverConfigurationName")
                    .role(McpSchema.Role.ASSISTANT)
                    // .content(Content)
                    .model("claude-3-sonnet-20240307")
                    .stopReason(StopReason.END_TURN)
                    .build();
            return result;
        });

        // Adds a consumer to be notified when the available tools change, such as tools
        // being added or removed.
        spec.toolsChangeConsumer((List<McpSchema.Tool> tools) -> {
            System.out.println("Tools changed: " + tools.get(0).name());
        });

        // Adds a consumer to be notified when the available resources change, such as
        // resources
        // being added or removed.
        spec.resourcesChangeConsumer((List<McpSchema.Resource> resources) -> {
            System.out.println("Resource changed: " + resources.get(0).name());
        });

        // Adds a consumer to be notified when the available prompts change, such as
        // prompts
        // being added or removed.
        spec.promptsChangeConsumer((List<McpSchema.Prompt> prompts) -> {
            // Handle prompts change
        });

        // Adds a consumer to be notified when logging messages are received from the
        // server.
        spec.loggingConsumer((McpSchema.LoggingMessageNotification log) -> {
            System.out.println("Liging changed: " + log);
        });
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/model/AggregatedResult.java
================
package com.example.coordinator.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Map;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AggregatedResult {
    private String coordinationId;
    private List<WorkerTask> completedTasks;
    private Map<String, Object> aggregatedData;
    private String summary;
    private long totalProcessingTime;
    private String status;
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/model/TaskAssignmentDTO.java
================
package com.example.coordinator.model

import lombok.Data;

@Data
public class TaskAssignmentDTO {
    private String agent;
    private String assigned_subtask;
    private String reason;

    public TaskAssignmentDTO() {}

    public TaskAssignmentDTO(String agent, String assigned_subtask, String reason) {
        this.agent = agent;
        this.assigned_subtask = assigned_subtask;
        this.reason = reason;
    }

    @Override
    public String toString() {
        return "TaskAssignment{" +
                "agent='" + agent + '\'' +
                ", assigned_subtask='" + assigned_subtask + '\'' +
                ", reason='" + reason + '\'' +
                '}';
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/model/WorkerSkilsDTO.java
================
package com.example.coordinator.model;

import java.util.List;

import lombok.Data;

@Data
public class WorkerSkilsDTO {
    private final String name;
    private final String serverUrl;
    private final List<String> skills;
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/model/WorkerTask.java
================
package com.example.coordinator.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class WorkerTask {
    private String taskId;
    private String workerId;
    private String input;
    private String skillId;
    private String status;
    private String result;
    private long timestamp;
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/service/WorkerAgentService.java
================
package com.example.coordinator.service;

import java.util.UUID;

import net.kaduk.a2a.A2AAgent;
import net.kaduk.a2a.Message;
import net.kaduk.a2a.Part;
import net.kaduk.a2a.Task;
import net.kaduk.a2a.TaskIdParams;
import net.kaduk.a2a.TaskQueryParams;
import net.kaduk.a2a.TaskState;
import net.kaduk.a2a.TextPart;

// import com.oracle.a2a.client.A2AClient;
// import com.oracle.a2a.model.Message;
// import com.oracle.a2a.model.Part;
// import com.oracle.a2a.model.Task;
// import com.oracle.a2a.model.TaskSendParams;
// import com.oracle.a2a.model.TaskState;
// import com.oracle.a2a.model.TextPart;

public class WorkerAgentService {

    private String getWorkerResponse(String prompt, A2AAgent client) {
        // Use TaskSendParams instead of TaskIdParams to set both ID and Message
        TaskQueryParams params = new TaskQueryParams();
        params.setId(UUID.randomUUID().toString()); // Generate a unique task ID

        Message message = new Message();
        message.setRole("user");

        TextPart textPart = new TextPart();
        textPart.setText("Hello! Can you help me with some information?");

        message.setParts(java.util.Collections.singletonList(textPart));
        params.setMessage(message);

        // Example 1: Send a synchronous request
        System.out.println("\n=== Synchronous Request ===");
        Task response = client.sendMessage(params);
        System.out.println("Task ID: " + response.getId());
        System.out.println("State: " + response.getStatus().getState());

        // If the task is State is working, loop until it is completed
        // If the task is State is working, loop until it is completed
        while (response.getStatus().getState().equals(TaskState.WORKING)) {
            System.out.println("Task is still working...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } // Wait for 1 second before checking again
            response = client.getTask(response.getId(), 1);
        }
        System.out.println("Task completed with state: " + response.getStatus().getState());
        // System.out.println("Task result: " +
        // response.getArtifacts()[0].getDescription());

        // If the task is completed, print the agent's response
        String agentResponse = "Hello! Can you help me with some information?";
        if (response.getStatus().getMessage() != null) {
            Part responsePart = response.getStatus().getMessage().getParts()[0];
            if (responsePart instanceof TextPart) {
                System.out.println("Agent response: " + ((TextPart) responsePart).getText());
                agentResponse = ((TextPart) responsePart).getText();
            }
        }
        return agentResponse;
    }

}

================
File: coordinator-agent/src/main/java/com/example/coordinator/tools/PromptTemplateTools.java
================
package com.example.coordinator.tools;

public class PromptTemplateTools {

     private static final String COORDINATOR_QUERY_REWRITE_TEMPLATE = """
            You are a task distribution planner in a multi-agent system.
            Task: "Develop and deploy a machine learning model to predict customer churn using historical CRM data."
            Agents:
            - Alice: skills = ["data preprocessing", "agent url", "feature engineering"]
            - Bob: skills = ["model training",  "agent url", "hyperparameter tuning"]
            - Charlie: skills = ["deployment",  "agent url", "CI/CD", "monitoring"]

            Distribute the task into subtasks based on agent skills.
            Return output as JSON with fields: "agent", "assigned_subtask", "reason", "agent url".

            Distrubute the folloing task to the agents:
            {user_query}
            """;

}

================
File: coordinator-agent/src/main/java/com/example/coordinator/tools/TaskPromptGenerator.java
================
package com.example.coordinator.tools;

import java.util.List;

import com.example.coordinator.model.WorkerSkilsDTO;

// import com.oracle.mcp.client.kb.chat.model.WorkerSkilsDTO;

public class TaskPromptGenerator {



    public static String generatePrompt(String userQuery, List<WorkerSkilsDTO> agents) {
        StringBuilder agentDescriptions = new StringBuilder();
        for (WorkerSkilsDTO worker : agents) {
            String skillsFormatted = String.join("\", \"", worker.getSkills());
            agentDescriptions.append(String.format("-  %s: skills = [\"%s\"]\n", worker.getName(), skillsFormatted));
        }

        return String.format("""
                You are a task distribution planner in a multi-agent system.
                Task: %s
                Agents:
                %s
                Distribute the task into subtasks based on agent skills and plan the required sequence of tasks by defining task predecessors.
                Omit agents whose skills are unsuitable for the required task from the prepared workflow. 
                Return output as JSON with fields: "task namber", "agent", "assigned_subtask", "reason", "required predecessor".
                """, userQuery, agentDescriptions.toString().trim());
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/workflow/WorkflowController.java
================
package com.example.coordinator.workflow;


// import com.oracle.a2a.service.WorkflowOrchestrator;
// import com.oracle.a2a.workflow.WorkflowTask;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/workflow")
public class WorkflowController {
    
    private final WorkflowOrchestrator orchestrator;
    
    public WorkflowController(WorkflowOrchestrator orchestrator) {
        this.orchestrator = orchestrator;
    }
    

    //It is example, the logic will be used in chat loop, just after user request query response
    @PostMapping("/execute")
    public CompletableFuture<ResponseEntity<Map<Integer, String>>> executeWorkflow(
            @RequestBody List<WorkflowTask> tasks) {
        return orchestrator.executeWorkflow(tasks)
                .thenApply(ResponseEntity::ok)
                .exceptionally(ex -> ResponseEntity.internalServerError()
                        .body(Map.of(0, "Workflow execution failed: " + ex.getMessage())));
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/workflow/WorkflowOrchestrator.java
================
package com.example.coordinator.workflow;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
// import com.oracle.a2a.client.A2AClient;
// import com.oracle.a2a.model.Message;
// import com.oracle.a2a.model.Part;
// import com.oracle.a2a.model.TaskArtifactUpdateEvent;
// import com.oracle.a2a.model.TaskSendParams;
// import com.oracle.a2a.model.TaskState;
// import com.oracle.a2a.model.TaskStatusUpdateEvent;
// import com.oracle.a2a.model.TextPart;
import net.kaduk.a2a.A2AAgent;

@Service
public class WorkflowOrchestrator {
    private static final Logger logger = LoggerFactory.getLogger(WorkflowOrchestrator.class);

    private final ObjectMapper objectMapper;
    private final Map<String, A2AAgent> agentClients;

    // Store for tasks and their results
    private final Map<Integer, WorkflowTask> workflowTasks = new ConcurrentHashMap<>();
    private final Map<String, Integer> agentToTaskMap = new ConcurrentHashMap<>();
    private final Map<Integer, String> taskResults = new ConcurrentHashMap<>();

    // Workflow execution state
    private final AtomicBoolean workflowRunning = new AtomicBoolean(false);
    private CountDownLatch workflowCompletionLatch;

    public WorkflowOrchestrator(ObjectMapper objectMapper, Map<String, A2AAgent> agentClients) {
        this.objectMapper = objectMapper;
        this.agentClients = agentClients;
    }

    /**
     * Start the workflow execution based on the provided plan
     */
    public CompletableFuture<Map<Integer, String>> executeWorkflow(List<WorkflowTask> tasks) {
        // Reset workflow state
        resetWorkflowState();

        // Initialize workflow state
        tasks.forEach(task -> workflowTasks.put(task.getTaskNumber(), task));
        workflowRunning.set(true);
        workflowCompletionLatch = new CountDownLatch(tasks.size());

        // Find tasks that can be started immediately (no predecessors)
        List<WorkflowTask> readyTasks = tasks.stream()
                .filter(task -> task.getRequiredPredecessor() == null)
                .collect(Collectors.toList());

        // Start the ready tasks
        readyTasks.forEach(this::executeTask);

        // Return a future that will complete when the workflow is done
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Wait for workflow completion (with timeout for safety)
                boolean completed = workflowCompletionLatch.await(30, TimeUnit.MINUTES);
                if (!completed) {
                    throw new RuntimeException("Workflow execution timed out after 30 minutes");
                }
                return taskResults;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Workflow execution was interrupted", e);
            } finally {
                workflowRunning.set(false);
            }
        });
    }

    /**
     * Reset the workflow state
     */
    private void resetWorkflowState() {
        workflowTasks.clear();
        agentToTaskMap.clear();
        taskResults.clear();
        workflowRunning.set(false);
    }

    /**
     * Execute a specific task
     */
    private void executeTask(WorkflowTask task) {
        logger.info("Executing task #{}: {} using agent: {}",
                task.getTaskNumber(), task.getAssignedSubtask(), task.getAgent());

        updateTaskStatus(task.getTaskNumber(), "RUNNING");

        // Find the A2A client for this agent
        A2AClient client = agentClients.getOrDefault(
                task.getAgent().toLowerCase().replaceAll("\\s+", ""),
                agentClients.get("default"));

        if (client == null) {
            handleTaskFailure(task, new RuntimeException("No A2A client found for agent: " + task.getAgent()));
            return;
        }

        // Map agent to task for callback handling
        agentToTaskMap.put(task.getAgent(), task.getTaskNumber());

        // Build the message including any results from predecessors
        String taskMessage = buildTaskMessage(task);

        // Create task parameters with the message
        TaskSendParams params = new TaskSendParams();
        Message message = new Message();
        TextPart textPart = new TextPart();
        textPart.setText(taskMessage);
        message.setParts(new Part[] { textPart });
        params.setMessage(message);

        // Send the task to the agent with streaming updates
        try {
            client.sendAndSubscribe(
                    params,
                    this::handleStatusUpdate,
                    this::handleArtifactUpdate,
                    error -> handleTaskFailure(task, error))
                    .exceptionally(ex -> {
                        handleTaskFailure(task, ex);
                        return null;
                    });
        } catch (Exception e) {
            handleTaskFailure(task, e);
        }
    }

    /**
     * Build the task message, including any predecessor results
     */
    private String buildTaskMessage(WorkflowTask task) {
        StringBuilder messageBuilder = new StringBuilder();
        messageBuilder.append(task.getAssignedSubtask());

        // Append previous results if there are any
        if (task.getRequiredPredecessor() != null) {
            String predecessorResult = taskResults.get(task.getRequiredPredecessor());
            if (predecessorResult != null && !predecessorResult.isEmpty()) {
                messageBuilder.append("\n\nPrevious task result:\n");
                messageBuilder.append(predecessorResult);
            }
        }

        return messageBuilder.toString();
    }

    /**
     * Handle task status updates
     */
    private void handleStatusUpdate(TaskStatusUpdateEvent event) {
        logger.debug("Received status update for task: {}, status: {}",
                event.getId(), event.getStatus());

        if (event.getStatus().getState() != null && TaskState.fromValue(event.getStatus().getState().toString()) == TaskState.COMPLETED) {
            // Use content from the task, not getResponse()
            String result = event.getStatus().getMessage() != null ? event.getStatus().getMessage().toString()
                    : "No content";
            logger.info("Task completed with result: {}", result);

            // Find the task associated with this update
            Optional<Map.Entry<String, Integer>> taskEntry = agentToTaskMap.entrySet().stream()
                    .filter(entry -> event.getId().contains(entry.getKey()))
                    .findFirst();

            if (taskEntry.isPresent()) {
                Integer taskNumber = taskEntry.get().getValue(); // Fixed: use get() instead of getValue()
                WorkflowTask task = workflowTasks.get(taskNumber);

                // Store the result
                taskResults.put(taskNumber, result);
                updateTaskStatus(taskNumber, "COMPLETED");

                // Find and trigger dependent tasks
                triggerDependentTasks(taskNumber);

                // Mark this task as done
                workflowCompletionLatch.countDown();
            } else {
                logger.warn("Received status update for unknown task: {}", event.getId());
            }
        } else if ("failed".equals(event.getStatus())) { //FIXIT NOT String comparision
            // Get the error message
            String errorMessage = event.getStatus().getMessage() != null ? event.getStatus().getMessage().toString()
                    : "Unknown error";
            logger.error("Task failed: {}", errorMessage);

            // Find and fail dependent tasks as well
            Optional<Map.Entry<String, Integer>> taskEntry = agentToTaskMap.entrySet().stream()
                    .filter(entry -> event.getId().contains(entry.getKey()))
                    .findFirst();

            if (taskEntry.isPresent()) {
                Integer taskNumber = taskEntry.get().getValue(); // Fixed: use get() instead of getValue()
                updateTaskStatus(taskNumber, "FAILED");
                workflowCompletionLatch.countDown();
            }
        }
    }

    /**
     * Handle task artifact updates
     */
    private void handleArtifactUpdate(TaskArtifactUpdateEvent event) {
        logger.debug("Received artifact update: {}", event.getArtifact().getDescription());
        // Here you could store or process artifacts if needed
    }

    /**
     * Handle task failures
     */
    private void handleTaskFailure(WorkflowTask task, Throwable error) {
        logger.error("Task #{} failed: {}", task.getTaskNumber(), error.getMessage(), error);
        updateTaskStatus(task.getTaskNumber(), "FAILED");
        workflowCompletionLatch.countDown();
    }

    /**
     * Update task status
     */
    private void updateTaskStatus(int taskNumber, String status) {
        WorkflowTask task = workflowTasks.get(taskNumber);
        if (task != null) {
            task.setStatus(status);
            workflowTasks.put(taskNumber, task);
        }
    }

    /**
     * Trigger dependent tasks when a task completes
     */
    private void triggerDependentTasks(int completedTaskNumber) {
        // Find tasks that depend on the completed task
        List<WorkflowTask> dependentTasks = workflowTasks.values().stream()
                .filter(t -> Objects.equals(t.getRequiredPredecessor(), completedTaskNumber))
                .collect(Collectors.toList());

        // Execute each dependent task
        dependentTasks.forEach(this::executeTask);
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/workflow/WorkflowParser.java
================
package com.example.coordinator.workflow;

import java.util.List;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class WorkflowParser {
    public static List<WorkflowTask> parseTasks(String rawJson) {
        try {
            // Clean Markdown-style backticks and optional prefix like "ASSISTANT:"
            String cleaned = rawJson
                    .replaceAll("(?i)^ASSISTANT:\\s*", "") // remove prefix
                    .replaceAll("(?m)^```json\\s*", "") // remove ```json
                    .replaceAll("(?m)^```\\s*$", "") // remove closing ```
                    .trim();

            ObjectMapper mapper = new ObjectMapper();

            // Read as JsonNode to remap fields
            JsonNode root = mapper.readTree(cleaned);

            for (JsonNode node : root) {
                ((ObjectNode) node).set("taskNumber", node.get("task number"));
                ((ObjectNode) node).set("assignedSubtask", node.get("assigned_subtask"));
                ((ObjectNode) node).set("requiredPredecessor", node.get("required predecessor"));
            }

            return mapper.readerFor(new TypeReference<List<WorkflowTask>>() {
            }).readValue(root);
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse workflow tasks", e);
        }
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/workflow/WorkflowTask.java
================
package com.example.coordinator.workflow;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class WorkflowTask {
    private int taskNumber;
    private String agent;
    private String assignedSubtask;
    private String reason;
    private Integer requiredPredecessor;
    private String result;
    private String status = "PENDING";
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/CoordinatorAgent.java
================
package com.example.coordinator;

import com.example.coordinator.model.AggregatedResult;
import net.kaduk.a2a.A2AAgent;
import net.kaduk.a2a.A2AAgentSkill;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.UUID;

@A2AAgent(
    name = "CoordinatorAgent", 
    version = "1.0", 
    description = "Coordinates tasks between multiple worker agents",
    url = "http://localhost:8080"
)
@Component
public class CoordinatorAgent {

    @Autowired
    private TaskDispatcher taskDispatcher;

    @A2AAgentSkill(
        id = "coordinate", 
        name = "Coordinate Multi-Agent Task", 
        description = "Dispatches work to multiple agents and aggregates results",
        tags = {"coordination", "orchestration", "multi-agent"}
    )
    public String coordinate(String input) {
        String coordinationId = UUID.randomUUID().toString();
        
        System.out.println("Coordinator received request: " + input);
        
        try {
            AggregatedResult result = taskDispatcher.dispatchAndAggregateWork(input, coordinationId).block();
            
            if (result != null && "completed".equals(result.getStatus())) {
                return String.format(
                    "Coordination completed in %dms. Summary: %s",
                    result.getTotalProcessingTime(),
                    result.getSummary()
                );
            } else {
                return "Coordination failed: " + (result != null ? result.getSummary() : "Unknown error");
            }
        } catch (Exception e) {
            System.err.println("Coordination error: " + e.getMessage());
            return "Coordination failed with error: " + e.getMessage();
        }
    }

    @A2AAgentSkill(
        id = "status", 
        name = "Get Task Status", 
        description = "Returns the status of active coordination tasks",
        tags = {"status", "monitoring"}
    )
    public String getStatus() {
        int activeTasks = taskDispatcher.getActiveTasks().size();
        return String.format("Coordinator active with %d tasks in progress", activeTasks);
    }

    @A2AAgentSkill(
        id = "ping", 
        name = "Ping", 
        description = "Simple health check",
        tags = {"health", "ping"}
    )
    public String ping(String message) {
        return "Coordinator pong: " + (message != null ? message : "");
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/CoordinatorApplication.java
================
package com.example.coordinator;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages = {"com.example.coordinator", "net.kaduk.a2a"})
public class CoordinatorApplication {
    public static void main(String[] args) {
        SpringApplication.run(CoordinatorApplication.class, args);
    }
}

================
File: coordinator-agent/src/main/java/com/example/coordinator/TaskDispatcher.java
================
package com.example.coordinator;

import com.example.coordinator.model.AggregatedResult;
import com.example.coordinator.model.WorkerTask;
import net.kaduk.a2a.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class TaskDispatcher {

    @Autowired
    private A2AWebClientService a2aClient;

    private final Map<String, WorkerTask> activeTasks = new ConcurrentHashMap<>();
    
    private static final String WORKER_A_URL = "http://localhost:8081/agent/message";
    private static final String WORKER_B_URL = "http://localhost:8082/agent/message";

    public Mono<AggregatedResult> dispatchAndAggregateWork(String input, String coordinationId) {
        long startTime = System.currentTimeMillis();
        
        System.out.println("Starting coordination for input: " + input);
        
        WorkerTask taskA = createWorkerTask("worker-a", input, "transform", coordinationId);
        WorkerTask taskB = createWorkerTask("worker-b", input, "analyze", coordinationId);
        
        activeTasks.put(taskA.getTaskId(), taskA);
        activeTasks.put(taskB.getTaskId(), taskB);

        Mono<SendMessageSuccessResponse> workerAResponse = sendTaskToWorker(WORKER_A_URL, taskA);
        Mono<SendMessageSuccessResponse> workerBResponse = sendTaskToWorker(WORKER_B_URL, taskB);

        return Mono.zip(workerAResponse, workerBResponse)
                .map(tuple -> {
                    SendMessageSuccessResponse responseA = tuple.getT1();
                    SendMessageSuccessResponse responseB = tuple.getT2();
                    
                    System.out.println("Received responses from both workers");
                    
                    String resultA = extractResultFromResponse(responseA);
                    String resultB = extractResultFromResponse(responseB);
                    
                    System.out.println("Worker A result: " + resultA);
                    System.out.println("Worker B result: " + resultB);
                    
                    taskA.setResult(resultA);
                    taskA.setStatus("completed");
                    taskB.setResult(resultB);
                    taskB.setStatus("completed");
                    
                    activeTasks.remove(taskA.getTaskId());
                    activeTasks.remove(taskB.getTaskId());
                    
                    return AggregatedResult.builder()
                            .coordinationId(coordinationId)
                            .completedTasks(Arrays.asList(taskA, taskB))
                            .aggregatedData(Map.of(
                                    "originalInput", input,
                                    "transformedText", resultA,
                                    "analysisResult", resultB,
                                    "combinedLength", resultA.length() + resultB.length()
                            ))
                            .summary(String.format(
                                    "Successfully coordinated processing of '%s'. Transformation: '%s', Analysis: '%s'", 
                                    input, resultA, resultB))
                            .totalProcessingTime(System.currentTimeMillis() - startTime)
                            .status("completed")
                            .build();
                })
                .timeout(Duration.ofSeconds(30))
                .doOnError(error -> {
                    System.err.println("Coordination failed: " + error.getMessage());
                    activeTasks.remove(taskA.getTaskId());
                    activeTasks.remove(taskB.getTaskId());
                })
                .onErrorReturn(AggregatedResult.builder()
                        .coordinationId(coordinationId)
                        .status("failed")
                        .summary("Failed to complete worker tasks: coordination timeout or error")
                        .totalProcessingTime(System.currentTimeMillis() - startTime)
                        .build());
    }

    private WorkerTask createWorkerTask(String workerId, String input, String skillId, String coordinationId) {
        return WorkerTask.builder()
                .taskId(UUID.randomUUID().toString())
                .workerId(workerId)
                .input(input)
                .skillId(skillId)
                .status("dispatched")
                .timestamp(System.currentTimeMillis())
                .build();
    }

    private Mono<SendMessageSuccessResponse> sendTaskToWorker(String workerUrl, WorkerTask task) {
        System.out.println("Sending task to worker: " + workerUrl + " with skill: " + task.getSkillId());
        
        SendMessageRequest request = SendMessageRequest.builder()
                .id(UUID.randomUUID().toString())
                .params(MessageSendParams.builder()
                        .message(Message.builder()
                                .kind("message")
                                .messageId(UUID.randomUUID().toString())
                                .role("user")
                                .taskId(task.getSkillId())
                                .contextId(task.getTaskId())
                                .parts(Collections.singletonList(TextPart.builder()
                                        .text(task.getInput())
                                        .build()))
                                .build())
                        .configuration(MessageSendConfiguration.builder()
                                .acceptedOutputModes(Collections.singletonList("text/plain"))
                                .blocking(true)
                                .build())
                        .build())
                .build();

        return a2aClient.sendMessage(workerUrl, request)
                .doOnSuccess(response -> {
                    task.setStatus("completed");
                    System.out.println("Task " + task.getTaskId() + " completed for worker " + task.getWorkerId());
                })
                .doOnError(error -> {
                    task.setStatus("failed");
                    System.err.println("Task " + task.getTaskId() + " failed for worker " + task.getWorkerId() + ": " + error.getMessage());
                });
    }

    private String extractResultFromResponse(SendMessageSuccessResponse response) {
        if (response != null && response.getResult() != null) {
            Message resultMessage = response.getResult();
            if (resultMessage.getParts() != null && !resultMessage.getParts().isEmpty()) {
                Part firstPart = resultMessage.getParts().get(0);
                if (firstPart instanceof TextPart) {
                    return ((TextPart) firstPart).getText();
                }
            }
        }
        return "No result received";
    }

    public Map<String, WorkerTask> getActiveTasks() {
        return new HashMap<>(activeTasks);
    }
}

================
File: coordinator-agent/src/main/resources/application.yml
================
server:
  port: 8080

spring:
  application:
    name: coordinator-agent

logging:
  level:
    com.example.coordinator: DEBUG
    net.kaduk.a2a: DEBUG




================================================================
End of Codebase
================================================================
